from flask import session  # type: ignore
from flask_socketio import emit  # type: ignore
from .models import ConversationLog
from . import db
from .services import get_next_question
import openai  # type: ignore

def register_socket_handlers(socketio, app):
    """
    Registers all the WebSocket event handlers for the Flask-SocketIO server.

    Parameters:
    -----------
    socketio : flask_socketio.SocketIO
        The Flask-SocketIO server instance.
    app : flask.Flask
        The Flask application instance for logging and context.

    WebSocket Events:
    -----------------
    - connect: Triggered when a new WebSocket client connects.
    - message: Triggered when the server receives a message from a client.
    - disconnect: Triggered when a client disconnects from the WebSocket server.

    Example Usage:
    --------------
    register_socket_handlers(socketio, app)
    """

    @socketio.on('connect')
    def handle_connect():
        """
        Handles a new WebSocket client connection.

        When a client connects, this function logs the event and sets a default `user_id`
        in the session if not already present. Emits a welcome message back to the client.
        """
        app.logger.info("Client connected via WebSocket")
        
        # Set a default user ID for the session (for demonstration/testing purposes)
        if 'conversation_stage' not in session:
            session['conversation_stage'] = 0  # Initialize conversation stage
        if 'user_id' not in session:
            session['user_id'] = 1
            app.logger.info("Session user_id set to 1 for the new connection.")
        
        # Get the first question
        first_question = get_next_question(session['conversation_stage'])
        # Send a welcome message to the newly connected client
        emit('response', {'id': '0', 'message': 'Welcome! You are now connected to the server.'})

    @socketio.on('message')
    def handle_message(data):
        """
        Handles incoming messages from WebSocket clients.

        Stores the received message in the database and sends a response generated by OpenAI
        back to the client. The message is broadcasted to all connected clients.

        Parameters:
        -----------
        data : str
            The message content sent by the client.
        """
        try:
            # Retrieve the user ID from the session (default to 1 if not set)
            user_id = session.get('user_id', 1)
            conversation_stage = session.get('conversation_stage', 0)

            app.logger.info(f"Message received from user {user_id}: {data}")

            # Store the received message in the database
            new_message = ConversationLog(user_id=user_id, message=data)
            db.session.add(new_message)
            db.session.commit()
            app.logger.info(f"Message {new_message.id} saved to the database.")

            # Generate an AI response using OpenAI's ChatCompletion endpoint
            ai_response = generate_openai_response(data)
            if ai_response is None:
                ai_response = "Sorry, I couldn't generate a response at the moment."

            # Send the AI response back to the client and broadcast it
            response_data = {'id': str(new_message.id), 'message': ai_response}
            emit('response', response_data, broadcast=True)
            app.logger.info(f"Response sent to user {user_id}: {ai_response}")

        except Exception as e:
            app.logger.error(f"Error handling message: {str(e)}")
            emit('response', {'id': '0', 'message': f"An error occurred: {str(e)}"})
            
        # Advance to the next question
        session['conversation_stage'] += 1
        next_question = get_next_question(session['conversation_stage'])

        if next_question:
            emit('response', {'id': str(new_message.id), 'message': next_question['question']})
        else:
            emit('response', {'id': str(new_message.id), 'message': 'Conversation complete!'})


    @socketio.on('disconnect')
    def handle_disconnect():
        """
        Handles a WebSocket client disconnection.

        Logs the disconnection event and can be used to perform cleanup if needed.
        """
        app.logger.info("Client disconnected from WebSocket")

def generate_openai_response(user_message):
    """
    Generates a response using OpenAI's GPT-3.5-turbo model based on the user's message.

    Parameters:
    -----------
    user_message : str
        The message content sent by the client, which will be used to generate the AI response.

    Returns:
    --------
    str
        The AI-generated response content. If an error occurs, `None` is returned.
    """
    try:
        # Construct the message history for the OpenAI API call
        messages = [{"role": "user", "content": user_message}]

        # Generate a response using OpenAI's ChatCompletion endpoint
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=messages,
            max_tokens=100,
            n=1,
            stop=None
        )

        # Extract and return the response content
        return response['choices'][0]['message']['content'].strip()
    except openai.error.OpenAIError as oe:
        # Log specific OpenAI errors for better traceability
        app.logger.error(f"OpenAI API Error: {str(oe)}") # type: ignore
        return None
    except Exception as e:
        # Log unexpected errors
        app.logger.error(f"Unexpected error in OpenAI response generation: {str(e)}") # type: ignore
        return None
